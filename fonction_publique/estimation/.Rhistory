##  Paths ####
rm(list = ls()); gc()
user = "simrab"
if (user == "simrab")
{
wd =  'U:/Projets/CNRACL/fonction-publique/fonction_publique/estimation/'
data_path = "M:/CNRACL/output/"
save_model_path = "Q:/CNRACL/predictions/"
simul_path  = "M:/CNRACL/simulation/results/"
python_file_path = 'U:/Projets/CNRACL/fonction-publique/fonction_publique/estimation/'
git_path =  'XXX/IPP/CNRACL'
fig_path = "Q:/CNRACL/Note CNRACL/Figures/"
tab_path = "Q:/CNRACL/Note CNRACL/Figures/"
}
setwd(wd)
if (user == "temp")
{
wd =  'C:/Users/s.rabate/Desktop/temp/estimation/'
data_path = "C:/Users/s.rabate/Desktop/temp/data/"
save_model_path = "C:/Users/s.rabate/Desktop/temp/predictions/"
simul_path  = "C:/Users/s.rabate/Desktop/temp/simulation/results/"
python_file_path = 'C:/Users/s.rabate/Desktop/temp/estimation/'
git_path =  'XXX/IPP/CNRACL'
fig_path = "C:/Users/s.rabate/Desktop/temp/Note CNRACL/Figures/"
tab_path = "C:/Users/s.rabate/Desktop/temp/Note CNRACL/Figures/"
}
setwd(wd)
### 0. Initialisation ####
source(paste0(wd, "0_Outils_CNRACL.R"))
# Load results
load(paste0(simul_path, "predictions9_min.Rdata"))
## NEW FILTER: à déplacer dans select_data
list_id = unique(output_global$ident[which(output_global$echelon == -1)])
print(paste0("Individus avec échelon = -1 :  ", length(list_id)))
output_global = output_global[which(!is.element(output_global$ident, list_id)), ]
list_id = unique(output_global$ident[which(output_global$generation >= 1990)])
print(paste0("Individus nés après 1990:  ", length(list_id)))
output_global = output_global[which(!is.element(output_global$ident, list_id)), ]
output_global$next_ib = ave(output_global$ib, output_global$ident, FUN = shift1)
output_global$gain_ib = (output_global$next_ib - output_global$ib)/output_global$ib
list_id = unique(output_global$ident[which(output_global$gain_ib >= 0.2 & !is.na(output_global$gain_ib))])
print(paste0("Individus avec une hausse d'ib de +20% :  ", length(list_id)))
output_global = output_global[which(!is.element(output_global$ident, list_id)), ]
table(output_global$echelon)
load(paste0(simul_path, "predictions9_min.Rdata"))
table(output_global$echelon)
################ Simulation with multinomial logit ################
# Simulation of trajectories based on estimation of the model.
# Two types of simulations:
#     i) Simulation of grade exit (2011 --> 2015)
#     ii)  Simulation of next ib (2011 --> 2012)
# Program:
# 0.  Initialisation: data loading and variable creations
# I.  Estimation: estimation of the models for predictions
# II. Simulation: from estimates, creating the two outputs for simulation diagnosis.
#### 0. Initialisation ####
source(paste0(wd, "0_Outils_CNRACL.R"))
load(paste0(save_model_path, "mlog.rda"))
load(paste0(save_model_path, "m1_seq.rda"))
load(paste0(save_model_path, "m2_seq.rda"))
load(paste0(save_model_path, "m1_by_grade.rda"))
set.seed(1234)
generate_data_sim <- function(data_path, use = "min")
{
datasets = load_and_clean(data_path, dataname = "filter/data_ATT_2011_filtered_after_duration_var_added_new.csv")
if (use == "max"){data = datasets[[1]]}
if (use == "min"){data = datasets[[2]]}
list_var = c("ident", "annee",  "sexe", "c_cir_2011", "generation", "an_aff", "grade",
"E_exam", "E_choice", "D_exam", "D_choice",
"time", "anciennete_dans_echelon", "echelon", "ib")
data = data[which(data$left_censored == F  & data$annee == 2011 & data$generation < 1990),
list_var ]
data_sim  =  create_variables(data)
data_sim = data_sim[order(data_sim$ident), ]
return(data_sim)
}
generate_data_output <- function(data_path)
{
dataname = "filter/data_ATT_2011_filtered_after_duration_var_added_new.csv"
filename = paste0(data_path, dataname)
data_long = read.csv(filename)
data_long$grade = data_long$c_cir
data_long$situation = data_long$next_grade_situation
list_var = c("ident", "annee", "c_cir_2011", "sexe", "generation", "grade","ib", "echelon", "situation", "annee_entry_min", "annee_entry_max", "an_aff")
output = data_long[which(data_long$annee >= 2011 & data_long$annee <= 2015), list_var]
output$I_bothC = NULL
return(output[, list_var])
}
save_prediction_R <- function(data, annee, save_path, modelname)
{
data$corps = "ATT"
data$next_situation = data$yhat
data = data[, c("ident", "annee", "corps", "grade", "ib", "echelon", "anciennete_dans_echelon", "next_situation")]
filename = paste0(save_path, annee, "_data_simul_withR_",modelname,".csv")
write.csv(data, file = filename)
print(paste0("Data ", filename, " saved"))
}
launch_prediction_Py <- function(annee, modelname, debug = F)
{
input_name = paste0(annee, "_data_simul_withR_",modelname,".csv")
output_name = paste0(annee, "_data_simul_withPy_",modelname,".csv")
input_arg = paste0(" -i ", input_name)
output_arg = paste0(" -o ", output_name)
d = ifelse(debug, " -d", "")
args = paste0(input_arg, output_arg, d)
command =  paste0('simulation',  args)
shell(command)
}
load_simul_py <- function(annee, modelname)
{
filename = paste0(simul_path, paste0(annee, "_data_simul_withPy_",modelname,".csv"))
simul = read.csv(filename)
simul = simul[order(simul$ident),-1]
#names(simul) = c("ident", "next_annee", "next_grade", "next_echelon", "next_annicennete_dans_echelon")
return(simul)
}
# Prédiction du changement de grade pour le modèle multinomial simple
predict_next_year_MNL <- function(data_sim, model, modelname)
{
adhoc <- sample(c("no_exit",   "exit_next", "exit_oth"), nrow(data_sim), replace=TRUE, prob = c(0.2, 0.2, 0.6))
data_sim$next_year <-adhoc
data_sim$grade <-as.character(data_sim$grade)
# Prediction for AT grade
data_AT = data_sim[which(is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_predict_MNL <- mlogit.data(data_AT, shape = "wide", choice = "next_year")
data_predict_MNL = data_predict_MNL[order(data_predict_MNL$ident, data_predict_MNL$alt),]
prob     <- predict(model, data_predict_MNL ,type = "response")
data_AT$yhat <- mapply(tirage_next_year_MNL, prob[,1], prob[,2], prob[,3])
# Correct 1: individuals in TTH4 cannot go in 'exit_next'
to_change = which(data_AT$grade == "TTH4" & data_AT$yhat == "exit_next")
rescale_p_no_exit = prob[,1]/(prob[,1]+prob[,3])
no_exit_hat   <- as.numeric(mapply(tirage, rescale_p_no_exit))
data_AT$yhat[to_change] <- ifelse(no_exit_hat[to_change]  == 1, "no_exit", "exit_oth")
# Correct 2: individuals in TTM1 or TTM2 stay in their grade.
if (length(unique(data_sim$grade)) > 4)
{
data_noAT = data_sim[which(!is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_noAT$yhat = "no_exit"
data_sim = rbind(data_AT, data_noAT)
}
if (length(unique(data_sim$grade)) <= 4)
{
data_sim = data_AT
}
data_sim = data_sim[order(data_sim$ident), ]
return(data_sim)
}
# Prédiction du changement de grade pour le modèle par grade
predict_next_year_byG <- function(data_sim, list_model, modelname)
{
adhoc <- sample(c("no_exit",   "exit_next", "exit_oth"), nrow(data_sim), replace=TRUE, prob = c(0.2, 0.2, 0.6))
data_sim$next_year <-adhoc
data_sim$grade <- as.character(data_sim$grade)
data_sim$yhat = ""
data_predict = mlogit.data(data_sim, shape = "wide", choice = "next_year")
data_predict = data_predict[order(data_predict$ident, data_predict$alt),]
# Prediction by grade
n = names(data_sim)
data_merge = as.data.frame(setNames(replicate(length(n),numeric(0), simplify = F), n))
list_grade = c("TTH1","TTH2", "TTH3", "TTH4")
for (g in 1:length(list_grade))
{
list_id_sim   = which(data_sim$grade == list_grade[g])
list_id_estim = which(data_predict$grade == list_grade[g])
model = list_model[[g]]
if (list_grade[g] != "TTH4")
{
prob     <- predict(model, data_predict[list_id_estim, ], type = "response")
data_sim$yhat[list_id_sim] = mapply(tirage_next_year_MNL, prob[,1], prob[,2], prob[,3])
}
if (list_grade[g] == "TTH4")
{
prob     <- predict(model, data_sim[list_id_sim, ] ,type = "response")
pred     <- as.numeric(mapply(tirage, prob))
data_sim$yhat[list_id_sim] = ifelse(pred == 1, "exit_oth", "no_exit")
}
}
# No exit quand hors du corps
if (length(unique(data_sim$grade)) > 4)
{
list_hors_corps = which(!is.element(data_sim$grade, list_grade))
data_sim$yhat[list_hors_corps] = "no_exit"
}
data_sim = data_sim[order(data_sim$ident), ]
# Checks
stopifnot(length(which(data_sim$yhat == "")) == 0)
return(data_sim)
}
predict_next_year_seq_m1 <- function(data_sim, m1, m2, modelname)
{
# Prediction for AT grade
data_AT = data_sim[which(is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
prob1     <- predict(m1, data_AT, type = "response")
pred1     <- as.numeric(mapply(tirage, prob1))
prob2     <- predict(m2, data_AT, type = "response")
pred2     <- as.numeric(mapply(tirage, prob2))
data_AT$yhat <- ifelse(pred1 == 1, "exit", "no_exit")
data_AT$yhat[which(pred1 == 1 & pred2 == 1)] <- "exit_next"
data_AT$yhat[which(pred1 == 1 & pred2 == 0)] <- "exit_oth"
# Correct: exit_next to oth when TTH4.
data_AT$yhat[which(data_AT$grade == "TTH4" & data_AT$yhat == "exit_next")] <- "exit_oth"
if (length(unique(data_sim$grade)) > 4)
{
data_noAT = data_sim[which(!is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_noAT$yhat = "no_exit"
data_sim = rbind(data_AT, data_noAT)
}
if (length(unique(data_sim$grade)) <= 4)
{
data_sim = data_AT
}
data_sim = data_sim[order(data_sim$ident), ]
return(data_sim)
}
predict_next_year_seq_m2 <- function(data_sim, m1, m2, modelname)
{
# Prediction for AT grade
data_AT = data_sim[which(is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
prob1     <- predict(m1, data_AT, type = "response")
pred1     <- as.numeric(mapply(tirage, prob1))
prob2     <- predict(m2, data_AT, type = "response")
pred2     <- as.numeric(mapply(tirage, prob2))
data_AT$yhat <- ifelse(pred1 == 1, "exit_oth", "no_exit")
data_AT$yhat[which(pred1 == 0 & pred2 == 1)] <- "exit_next"
data_AT$yhat[which(pred1 == 0 & pred2 == 0)] <- "no_exit"
# Correct: exit_next to no_exit when TTH4.
data_AT$yhat[which(data_AT$grade == "TTH4" & data_AT$yhat == "exit_next")] <- "no_exit"
if (length(unique(data_sim$grade)) > 4)
{
data_noAT = data_sim[which(!is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_noAT$yhat = "no_exit"
data_sim = rbind(data_AT, data_noAT)
}
if (length(unique(data_sim$grade)) <= 4)
{
data_sim = data_AT
}
data_sim = data_sim[order(data_sim$ident), ]
return(data_sim)
}
increment_data_sim <- function(data_sim, simul_py)
{
# Deleting individuals with pbl
if (length(data_sim$ident) != length(simul_py$ident) | length(which(is.na(simul_py$ib)) >0 )  |
length(which(is.na(simul_py$grade)) >0 | length(which(!is.element(simul_py$echelon, seq(1,12))))>0 ))
{
list_pbl_id1 = unique(setdiff(data_sim$ident, simul_py$ident))
print(paste0("Il y a ",length(list_pbl_id1)," présents dans data_sim et absent dans simul"))
list_pbl_id2 = unique(setdiff(simul_py$ident, data_sim$ident))
print(paste0("Il y a ",length(list_pbl_id2)," présents dans simul et absent dans data_sim"))
list_pbl_ib = unique(simul_py$ident[which(is.na(simul_py$ib))])
print(paste0("Il y a ",length(list_pbl_ib)," individus dans la base simul  avec ib = NA"))
list_pbl_grade = unique(simul_py$ident[which(is.na(simul_py$grade) | simul_py$grade == "nan")])
print(paste0("Il y a ",length(list_pbl_grade)," individus dans la simul  avec grade = NA"))
list_pbl_echelon = unique(simul_py$ident[which(!is.element(simul_py$echelon, seq(1,12)))])
print(paste0("Il y a ",length(list_pbl_grade)," individus dans la simul  avec echelon bizarre"))
deleted_id = Reduce(union, list(list_pbl_id1, list_pbl_id2, list_pbl_ib, list_pbl_grade, list_pbl_echelon))
stopifnot(length(deleted_id) == 0)
data_sim = data_sim[which(!is.element(data_sim$ident, deleted_id)), ]
simul_py = simul_py[which(!is.element(simul_py$ident, deleted_id)), ]
print(paste0("Il y a ",length(unique(data_sim$ident))," individus dans la base en ", annee+1))
}
# Merge
list_var_kept1 = c("ident",  "sexe", "generation", "an_aff", "c_cir_2011",
"E_exam", "E_choice", "D_exam", "D_choice", "time")
list_var_kept2 = c("annee", "grade", "echelon", "ib", "anciennete_dans_echelon", "situation")
data_merge = cbind(data_sim[,list_var_kept1], simul_py[, list_var_kept2])
# Increment time
data_merge$time[which(data_merge$situation == "no_exit")] = data_merge$time[which(data_merge$situation == "no_exit")] + 1
data_merge$time[which(data_merge$situation != "no_exit")] = 1
# Recreate variables (duration, thresholds with new time and echelons)
data_merge  =  create_variables(data_merge)
data_merge = data_merge[order(data_merge$ident), ]
return(data_merge)
}
save_results_simul <- function(output, data_sim, modelname)
{
var = c("grade", "anciennete_dans_echelon", "echelon", "ib", "situation", "I_bothC")
new_var = paste0(c("grade", "anciennete_dans_echelon", "echelon", "ib", "situation", "I_bothC"), "_", modelname )
data_sim[, new_var] = data_sim[, var]
add = data_sim[, c("ident", "annee", new_var)]
# Merge
output = rbind(output, add)
output = output[order(output$ident, output$annee),]
return(output)
}
########## II. Simulation #########
output_global = generate_data_output(data_path)
add = generate_data_output(data_path)
for (m in 1:6)
{
if (m <= 3){modelname  =  paste0("MNL_", toString(m))}
if (m == 4){modelname = "BG_1"}
if (m == 5){modelname = "MS_1"}
if (m == 6){modelname = "MS_2"}
print(paste0("Simulation for model ", modelname))
for (annee in 2011:2014)
{
print(paste0("Annee ", annee))
if (annee == 2011)
{
data_sim = generate_data_sim(data_path, use = "min")
output = data_sim[, c("ident", "annee", "grade","ib", "anciennete_dans_echelon", "echelon", "I_bothC")]
output = rename(output, c("grade"=paste0("grade_", modelname) ,
"ib"=paste0("ib_", modelname),
"anciennete_dans_echelon"=paste0("anciennete_dans_echelon_", modelname),
"echelon"=paste0("echelon_", modelname),
"I_bothC"=paste0("I_bothC_", modelname)))
output[, paste0("situation_", modelname)] = NA
}
# Prediction of next_situation from estimated model
if (m <= 3){pred =  predict_next_year_MNL(data_sim, model = list_MNL[[m]], modelname)}
if (m == 4){pred =  predict_next_year_byG(data_sim, list_by_grade, modelname)}
if (m == 5){pred =  predict_next_year_seq_m1(data_sim, step1_m1, step2_m1, modelname)}
if (m == 6){pred =  predict_next_year_seq_m2(data_sim, step1_m2, step2_m2, modelname)}
stopifnot(length(which(pred$yhat == "exit_next" & pred$grade == "TTH4")) == 0)
# Save prediction for Py simulation
output[which(output$annee == annee), paste0("situation_", modelname)] = pred$yhat
# Check
list_id1 = output$ident[which(output$annee == annee & output$situation_BG_1 == "exit_next")]
list_id2 = pred$ident[which(pred$yhat == "exit_next")]
stopifnot(length(setdiff(list_id1, list_id2))==0)
save_prediction_R(data = pred, annee, simul_path, modelname)
# Prediction of next_ib using simulation.py
launch_prediction_Py(annee, modelname)
# Load
simul_py = load_simul_py(annee, modelname)
# Incrementing data_sim for next year
data_sim = increment_data_sim(data_sim, simul_py)
# Save results
output = save_results_simul(output, data_sim, modelname)
}
output_global = merge(output_global, output, by = c("ident", "annee"), all.x = T)
}
cd
wd
simul_py = load_simul_py(annee, modelname)
data_sim = increment_data_sim(data_sim, simul_py)
table(data_sim$echelon)
annee = 2014
simul_py = load_simul_py(annee, modelname)
data_sim = increment_data_sim(data_sim, simul_py)
simul_py = load_simul_py(annee, modelname)
table(data_sim$echelon)
load(paste0(simul_path, "predictions9_min.Rdata"))
table(output_global$echelon)
table(output_global$echelon_BG_1)
table(output_global$echelon_BG_é)
table(output_global$echelon_BG_2)
table(output_global$echelon_MNL_1)
View(output_global)
check = output_global[which(output_global$echelon == 1),]
View(add)
View(data_sim)
View(check)
check = output_global[which(output_global$echelon == -1),]
View(check)
## NEW FILTER: à déplacer dans select_data
list_id = unique(output_global$ident[which(output_global$echelon == -1)])
print(paste0("Individus avec échelon = -1 :  ", length(list_id)))
output_global = output_global[which(!is.element(output_global$ident, list_id)), ]
list_id = unique(output_global$ident[which(output_global$generation >= 1990)])
print(paste0("Individus nés après 1990:  ", length(list_id)))
output_global = output_global[which(!is.element(output_global$ident, list_id)), ]
output_global$next_ib = ave(output_global$ib, output_global$ident, FUN = shift1)
output_global$gain_ib = (output_global$next_ib - output_global$ib)/output_global$ib
list_id = unique(output_global$ident[which(output_global$gain_ib >= 0.2 & !is.na(output_global$gain_ib))])
print(paste0("Individus avec une hausse d'ib de +20% :  ", length(list_id)))
output_global = output_global[which(!is.element(output_global$ident, list_id)), ]
# Proba de sortie vers grade next par grade et par échelon
subdata = output_global[which(output_global$annee == 2011 & output_global$c_cir_2011 != "TTH4"),]
subdata$situation_obs = subdata$situation
subdata$duration = 2011- subdata$annee_entry_min + 1
var = c("ident", "c_cir_2011", "echelon", "duration", "situation_obs", "situation_MNL_2",
"situation_MNL_3", "situation_MS_1", "situation_MS_2", "situation_BG_1")
subdata = subdata[, var]
df <- melt(subdata, id.vars = c(1:4), value.name = "next_year",  variable.name = "model")
df$model = substring(df$model, 11)
df$exit = ifelse(df$next_year == "exit_next", 1, 0)
comp_exit_by_ech = function(df, save = F, list_models, n_col, legend = F, grade)
{
df = df[which(df$c_cir_2011 == grade),]
ech = seq(range(df$echelon)[1],range(df$echelon)[2])
hazard = matrix(ncol = length(ech), nrow = length(list_models))
effectif = numeric(length(ech))
for (m in 1:length(list_models))
{
subdf = df[which(df$model == list_models[m]),]
for (e in 1:length(ech))
{
if (m ==1){effectif[e] = length(which(subdf$echelon == ech[e]))}
hazard[m, e] =   length(which(subdf$echelon == ech[e] & subdf$exit == 1))/length(which(subdf$echelon == ech[e]))
}
}
par(mar = c(4,4,1,1))
lim = c(0, max(hazard, na.rm = T))
plot(ech, rep(NA, length(ech)), ylim = lim, xlab = "ECHELON", ylab = "% EXIT NEXT GRADE")
for (m in 1:length(list_models))
{
lines(ech ,hazard[m, ], type = "l", lty = 1, lwd = 3, col = n_col[m])
}
par(new = T)
plot(ech, effectif, type ="l", lty = 2, lwd = 1, axes=F, xlab=NA, ylab=NA)
if (legend){legend("topleft", legend = c("Hazard", "Nb obs."), lwd = 3, lty = c(1,3), col = c("darkcyan", "black"), cex = 1.1)}
}
comp_exit_by_dur = function(df, save = F, list_models = c("obs", "MNL_2", "MNL_3", "BG_1"), n_col, legend = F, grade)
{
df = df[which(df$c_cir_2011 == grade),]
dur = seq(range(df$duration)[1],range(df$duration)[2])
hazard = matrix(ncol = length(dur), nrow = length(list_models))
effectif = numeric(length(dur))
for (m in 1:length(list_models))
{
subdf = df[which(df$model == list_models[m]),]
for (e in 1:length(dur))
{
if (m ==1){effectif[e] = length(which(subdf$duration == dur[e]))}
hazard[m, e] =   length(which(subdf$duration == dur[e] & subdf$exit == 1))/length(which(subdf$duration == dur[e]))
}
}
par(mar = c(4,4,1,1))
lim = c(0, max(hazard, na.rm = T))
plot(dur, rep(NA, length(dur)), ylim = lim, xlab = "DUREE DANS LE GRADE", ylab = "% EXIT NEXT GRADE")
for (m in 1:length(list_models))
{
lines(dur ,hazard[m, ], type = "l", lty = 1, lwd = 3, col = n_col[m])
}
par(new = T)
plot(dur, effectif, type ="l", lty = 2, lwd = 1, axes=F, xlab=NA, ylab=NA)
if (legend){legend("topleft", legend = c("Hazard", "Nb obs."), lwd = 3, lty = c(1,3), col = c("darkcyan", "black"), cex = 1.1)}
}
list_models = c("obs", "MNL_2", "MNL_3", "MS_1", "BG_1")
list_names = list_models
n_col <- c("black", "#727272","#f1595f","#79c36a","#599ad3", "#f9a65a", "#9e66ab", "#cd7058","#d77fb3")
for (grade in c("TTH1", "TTH2", "TTH3"))
{
pdf(paste0(fig_path, "comp_exit_pred_",grade,".pdf"))
layout(matrix(c(1,2,3, 3), nrow=2,ncol=2, byrow=F), heights =  c(3,3), widths = c(4,1))
# Graphe by ech
comp_exit_by_ech(df, list_models = list_models, n_col = n_col, grade = grade)
# Graphe by dur
comp_exit_by_dur(df, list_models = list_models, n_col = n_col, grade = grade)
# Legend
par(mar=c(0,0,0,0),font=1.5)
plot.new()
legend("left", legend=c(list_names, "Nb \nd'obs\n"), lty=c(rep(1, length(list_names)), 2), title = "Modèles",
col=c(n_col[1:length(list_names)],"black"),lwd=3,cex=1.2, ncol=1, bty = "n")
dev.off()
}
